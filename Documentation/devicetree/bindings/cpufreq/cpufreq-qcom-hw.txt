Qualcomm Technologies, Inc. CPUFREQ Bindings

CPUFREQ HW is a hardware engine used by some Qualcomm Technologies, Inc. (QTI)
SoCs to manage frequency in hardware. It is capable of controlling frequency
for multiple clusters.

Properties:
- compatible
	Usage:		required
	Value type:	<string>
	Definition:	must be "qcom,cpufreq-hw".

- clocks
	Usage:		required
	Value type:	<phandle> From common clock binding.
	Definition:	clock handle for XO clock.

- clock-names
	Usage:		required
	Value type:	<string> From common clock binding.
	Definition:	must be "xo".

* Property qcom,freq-domain
Devices supporting freq-domain must set their "qcom,freq-domain" property with
phandle to a freq_domain_table in their DT node.

* Frequency Domain Table Node

This describes the frequency domain belonging to a device.
This node can have following properties:

- reg
	Usage:		required
	Value type:	<prop-encoded-array>
	Definition:	Addresses and sizes for the memory of the HW bases.

Example:

Example 1: Dual-cluster, Quad-core per cluster. CPUs within a cluster switch
DCVS state together.

/ {
	cpus {
		#address-cells = <2>;
		#size-cells = <0>;

		CPU0: cpu@0 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x0>;
			enable-method = "psci";
			next-level-cache = <&L2_0>;
			qcom,freq-domain = <&freq_domain_table0>;
			L2_0: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
				L3_0: l3-cache {
				      compatible = "cache";
				};
			};
		};

		CPU1: cpu@100 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x100>;
			enable-method = "psci";
			next-level-cache = <&L2_100>;
			qcom,freq-domain = <&freq_domain_table0>;
			L2_100: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};

		CPU2: cpu@200 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x200>;
			enable-method = "psci";
			next-level-cache = <&L2_200>;
			qcom,freq-domain = <&freq_domain_table0>;
			L2_200: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};

		CPU3: cpu@300 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x300>;
			enable-method = "psci";
			next-level-cache = <&L2_300>;
			qcom,freq-domain = <&freq_domain_table0>;
			L2_300: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};

		CPU4: cpu@400 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x400>;
			enable-method = "psci";
			next-level-cache = <&L2_400>;
			qcom,freq-domain = <&freq_domain_table1>;
			L2_400: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};

		CPU5: cpu@500 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x500>;
			enable-method = "psci";
			next-level-cache = <&L2_500>;
			qcom,freq-domain = <&freq_domain_table1>;
			L2_500: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};

		CPU6: cpu@600 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x600>;
			enable-method = "psci";
			next-level-cache = <&L2_600>;
			qcom,freq-domain = <&freq_domain_table1>;
			L2_600: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};

		CPU7: cpu@700 {
			device_type = "cpu";
			compatible = "qcom,kryo385";
			reg = <0x0 0x700>;
			enable-method = "psci";
			next-level-cache = <&L2_700>;
			qcom,freq-domain = <&freq_domain_table1>;
			L2_700: l2-cache {
				compatible = "cache";
				next-level-cache = <&L3_0>;
			};
		};
	};

	qcom,cpufreq-hw {
		compatible = "qcom,cpufreq-hw";

		clocks = <&rpmhcc RPMH_CXO_CLK>;
		clock-names = "xo";

		#address-cells = <2>;
		#size-cells = <2>;
		ranges;
		freq_domain_table0: freq_table0 {
			reg = <0 0x17d43000 0 0x1400>;
		};

		freq_domain_table1: freq_table1 {
			reg = <0 0x17d45800 0 0x1400>;
		};
	};
};
